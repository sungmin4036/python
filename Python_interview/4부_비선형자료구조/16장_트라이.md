- 트라라이(Trie) : 검색 트리의 일종으로 일반적으로 키가 문자열인, 동적 배열 또는 연관 배열을 저장하는데 사용되는 정렬된 트리 자료 구조.

자연어 처리(NLP) 분야에서 문자열 탐색을 위한 자료구조로 널리 쓰인다.

초창기에는 '트리'로 발음 했으나 기존 트리와 구분하기위해 '트라이'로 불린다.

트라이는 트리와 유사하지만, 이진트리가 아닌 다진 트리(m-ary Tree) 형태를 띤다.

![image](https://user-images.githubusercontent.com/62640332/146950556-fb7f0fe7-eb8d-4a83-bf63-1925a4e4ca75.png)

트라이는 문자열을 위한 트리의 형태이기 떄문에 사실상 문자 개수만큼 자식이 있어 그림과 같이 나타내보면 상당히 많은 자식 노드를 갖고 있는 트리임을 확인 가능.

- 데코레이터(Decorator)
자바의 애노테이션(Annotation)이라 부르는 동일한 위치에 있으며, 파이썬에서는 데코레이터(Decorator)라 부른다.

그중에서 @staticmethod는 자바의 메소드 static 선언과 비슷. 이렇게 정의한 메소드는 클래스와 독립적인 함수로서의 의미를 강하게 갖는다.

실제로 파라미터에도 클래스 메소드에는 항상 따라붙는 self가 빠져있고, 함수 자체가 별도의 자료형으로 선언되어 있다.
```
class CLASS:
    def a(sef):
        pass

    @staticmethod
    def b():
        pass

-----------------
>>> type(CLASS.a), type(CLASS.b)
(<class 'funciton'>, <class 'function'>)
클래스를 생성하지 않고 바깥에서 직접 호출했을 때 타입은 함수(Function)가 된다.

>>> cls = CLASS()
>>> type(cls.a), type(cls.b)
(<class 'method'>, <class 'function'>)

그러나 클래스를 생성한 후에 함수에 대한 타입 물어보면 메소드(Method)가 된다.
그러나 @staticmethod로 선언한 함수는 여전히 함수이다.

사실상 클래스 바깥에 함수를 별도로 선언한 것과 같은 의미 가진다.
이렇게하면 클래스 메소드처럼 자유롭게 클래스 인스턴스에 접근하는것이 제한된다.
따라서, 클래스 인스턴스에 접근을 제한하고 분명하게 독립적인 함수로 선언하고자 할 경우 종종 사용된다.
```






  

ㅁ 트라이 구현 461p
ㅁ 팬린드롭 페어 466p