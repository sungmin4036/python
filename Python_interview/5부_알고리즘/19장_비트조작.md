![image](https://user-images.githubusercontent.com/62640332/147414451-6d42e22f-8408-41ab-9d2e-67737c4aa6ab.png)

![image](https://user-images.githubusercontent.com/62640332/147414530-493861c9-d7dd-4fac-8360-e276f145c615.png)

![image](https://user-images.githubusercontent.com/62640332/147414550-052e7ba3-d1ce-4335-a79f-d832dd5f12ee.png)

![image](https://user-images.githubusercontent.com/62640332/147414555-cb98c562-db47-4131-8900-f0e7d8c9e45c.png)

![image](https://user-images.githubusercontent.com/62640332/147414772-feaa9332-1729-413f-827b-a0d1e829fb71.png)

![image](https://user-images.githubusercontent.com/62640332/147414783-340581ae-4795-400b-b176-0928e87616f5.png)

2의 보수 숫자 포맷이고 숫자 표현 범위는 -2^n-1 ~ 2^n-1 -1이 된다.   
여기서 n=4 이기 떄문에 -8 ~ 7까지 표현 범위 이다.

 
![image](https://user-images.githubusercontent.com/62640332/147414878-c87f7030-e4f1-4bc2-9b37-9abcd1693251.png)

4비트로 2의 보수 표현 하는 방법중 하나로, 비트 마스크 사용하는 방식

CPython은 임의 정밀도(Arbitary-precision) 지원, 부호는 별도 필드를 갖고 있으며, 비트 연산 필요시에만 2의 보수로 변화하는 작업한다.

음수를 보여줄때 양의 정수를 표현방식과 동일하고 앞에 부호만 덧붙여서 보여준다.

```
>>> bin(-5)
'-0b101'

>>> 5 & -4
4

2의 보수 값을 실제로 보여주지 않으나, 4비트로 표현하는 32비트로 표현하든, 비트 연산 결과는 동일하다.

>>> bin(ob0101 & ob1100)
'0b100'

>>> bin(0b0000000000000000000101 & ob11111111111111111111111100)
'0b100'

4비트 2의 보수 표현과 32비트의 2의 보수 표현으로 바꿔서 비교해보면 다음과 같다.

>>> 5 | -4
-3
>>> bin(0b0101 | ob1100 )
'0b1101'

AND 연산도 동일 OR연산도 동일하다.
```

2의 보수 수학 연란 이란? 가산 역 연산 이라 부르며, 양수를 음수로, 음수를 양수를 바꾸는 작업을 말한다.

방법은, 비트 연산자 NOT 을 한 후에 1을 더하면 된다.

1. '비트 연사자 NOT'은 2의 보수에서 1을 뺸것.
2. '2의 보수 수학 연산'은 비트 연산자 NOT에서 1을 더한것.

0111의 2의 보수 연산은 1000 + 1 = 1001 이 된다.
1001의 비트 연산자 NOT은 0111 - 1 = 0110이다. 이값은 ~1001로 표현하기도 한다.

0111은 8이고, 2의 보수 연산을 한 결과는 1001은 -7로, 세로 축을 기준으로 서로 대칭 구조를 띤다.

즉 2의 보수 연산은 정확히 양수를 음수로, 또는 음수를 양수로 만들어 준다.

당연히 둘을 더하면 0이되고, 이진수로 계산시 0111 + 1001 = 10000로 자릿수 오버플로가 발생하여, 4비트 연산이므로 초과하여 자릿수는 무시하며 0000, 즉 0이된다.


- 비트 연산자 NOT   
~연산자인 비트 연산자 NOT은 기준 비트 내에서 정확히 1을 0으로, 0을 1로 바꿔준다.

4비트라 가정시 0111은 1000이며, 2의 보수 포맷에서 0111은 7, 1000은 -8로     
NOT x = -x -1 이 된다.

```
>>> bin(0b0101 ^ ~0b1100)
'-0b1010'

>>> bin(0b0000101 ^~0b00001100)
'-b1010'
```

ㅁ 싱글 넘버 552p

ㅁ 해밍 거리 554p

ㅁ 두 정수의 합 555p

ㅁ UTF-8 검증 561p

ㅁ 1비트의 개수 565p



