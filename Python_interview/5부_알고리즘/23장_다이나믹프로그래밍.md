- 다이나믹 프로그래밍 알고리즘은 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘.

다이나믹 알고리즘을 이용하면, 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우의 문제, 즉 최적 부분 구조(Optimal Substructure)을 갖고 있는 문제를 풀이할수 있다.

최적 부분 구조를 푸는 또 다른 알고리즘으로는 그리디 알고리즘이 있따.

서로 비슷한 유형의 문제를 풀이한다는 점에서 서로 비교 대상이 되기도 하는데, 그리디 알고리즘은 항상 그 순간이 최적이라 생각되는 것을 선택하면서 풀이해 나가는것이고, 다이나믹 프로그래밍은 중복된 하위 문제들의 결과를 저장해뒀다가 풀이해 나간다는 차이가 있따.

여기서 중요한것은 중복된 문제들이란 점이며, 중복되지 않은 문제는 다이나믹 프로그래밍으로 풀지 않는다.

 
![image](https://user-images.githubusercontent.com/62640332/147577202-869b6cc7-5918-463d-b613-45ecb8fff581.png)

ㅁ 최적 부분 구조

![image](https://user-images.githubusercontent.com/62640332/147577254-78a8b2ab-dcd3-4184-8c25-8640f0d0722a.png)

서울에서 부산까지 가는 최단 경로를 찾는 예이다.

최단 경로는 200 + 80 = 280 이다.   

최단 경로는 각각의 경로 문제인 1) 서울에서 대구까지 가는 최단 경로문제
                             2) 대구에서 부산까지 가는 최단 경로문제
의 문제의 해결 방법의 합이다. 따라서 문제의 최적 해결 방법은 부분 문제에 대한 최적 해결 방법으로 구성된다.

이러한 구조를 최적 부분 구조라하며, 이런유형의 문제는 분할 정복으로 풀 수 있다.

다이나믹 프로글매ㅣㅇ 또는 그리디 알고리즘으로 접근해볼 수 있는 문제의 후보가 된다.

만약 서울에서 부산까지 고속도로가 새롭게 개통되어 더이상 대구를 거칠수 없다면 더 이상 최적 부분 구조가 아니다.

<br>
<br>
<br>

ㅁ 중복된 하위 문제들

다이나믹 알고리즘으로 풀 수 있는 문제들과 다른 문제들의 결정적인 차이는 중복된 하이위 문제들을 갖는다는 것이다.

 
![image](https://user-images.githubusercontent.com/62640332/147577587-d7f86721-2724-443d-bb37-c31fd2cf2ac8.png)


파보니치 수열의 경우 리스트와 같은 계산 구조를 띤다.

f(3) = f(2) + f(1) 이며,
f(4) = f(3) + f(2) 이처럼 파보나치 수열을 재귀로 풀면 재귀적으로 동일한 하위 문제들이 발생한다. 이부분이 핵심이다.

중복 문제가 발생하지 않는 병합 정렬은 분할 정복으로 분류되지만, 파보니치 수열을 풀이하는 알고리즘은 다이나믹 프로그래밍의 대상으로 분류되는 이유다.

<br>
<br>
<br>
<br>

ㅁ 다이나믹 프로그래밍 방법론

 
![image](https://user-images.githubusercontent.com/62640332/147579315-b124e799-75e2-44e0-84c3-6c570df1d585.png)

이 그림에서 방법론은 방식에 따라 상향식과 하양식으로 나뉜다.

일반저으로 상향식은 타뷸레이션, 하양식은 메모이제이션 이라고 부른다.

- 상향식(Bottom-Up): 더 작은 하위 문제로부터 살펴본 다음, 작은 문제의 정답을 이용해 큰 문제의 정답을 풀어나간다. 즉, 작은 하위 문제부터 차례대로 정답을 풀어나가며 큰 문제의 정답을 만든다.
  
데이터를 테이블 형태로 만들면서 문제를 풀이한다고 하여 타뷸레이션(Tabulation)이라 부르며, 일반적으로 이 방식만을 다이나믹 프로그래밍으로 지칭하기도 한다.

```
def fib(n):
    dp[0] = 0
    dp[1] = 1

    for i in range(2, n + 1)
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```

- 하양식(Top_Down): 하위 문제에 대한 정답을 계산했는지 확인해가며 문제를 자연스러운 방식으로 풀어나간다. 

기존 재귀 풀이와 거의 동일하면서도 이미 풀어봤는지 확인하여 재활용하는 효율적인 방법으로 이 방식을 특별히 메모이제이션(Memoization)이라 지칭한다.

```
def fib(n):
    if n <= 1:
        return n

    if dp[n]:
        return dp[n]
    dp[n] = fib(n - 1) + fib(n - 2)
    return dp[n]
```

파보나치 수열은 재귀와 다이나믹 프로그래밍을 모두 한 번에 평가할 수 이쓴ㄴ 매우 좋은 문제다.

특히 알고리즘 자체가 간단하기 떄문에 테스트에 자주 등장한다.

![image](https://user-images.githubusercontent.com/62640332/147580985-175ccb05-873d-4c64-8792-0364ca2bd200.png)


![image](https://user-images.githubusercontent.com/62640332/147581141-a00c12aa-b5d2-45f2-b113-fb150bfdf7cc.png)




ㅁ 파보나치 수 627p

ㅁ 0-1 배낭문제 632p

ㅁ 최대 서브 배열 636p

ㅁ 계단 오르기 639p

ㅁ 집도둑 642p

