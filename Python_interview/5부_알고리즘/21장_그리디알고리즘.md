- 그리디 알고리즘은 글로벌 최적을 찾기 위해 각 단계에서 로컬 최적의 선택을 하는 휴리스틱 문제 해결 알고리즘 이다.

그리디 알고리즘이란 바로 눈앞의 이익만을 쫒는 알고리즘이다.

대부분 뛰어난 결과를 도출 못하지만, 드물게 최적해를 보장하는 경우도 있다.

그리디 알고리즘은 최적화 문제를 대상으로 한다. 최적해를 찾을 수 있으면 그것을 목표로 삼고, 찾기 어려운 경우에는 주어진 시간 내에 그런대로 괜찮은 해를 찾는것을 목표로 삼는다.

대부분의 문제들은 이런 로컬 최적해(Locally Optimum Solution)을 찾는 탐욕스런 방법으로는 문제를 해결할수 없다. 그러나 합리적인 시간 내에 최적에 가까운 답을
찾을수 있다는 점에서 매우 유용한 알고리즘이다.

그리디 알고리즘에서 잘 작동하는 문제들은 탐욕 선택 속성(Greedy Choice Property)을 갖고있는 최적 부분 구조(Optimal Substrucutre)인 문제들이다.

- 탐욕속성이란? 앞의 선택이후 선택에 영향을 주지 않는 것을 말한다.
다시말해 선택을 다시 고려하지 않는다.

- 최적 부분 구조란? 문제의 최적 해결 방법이 부분 문제애 대한 최적 해결 방법으로 구성되는 경우를 말한다.

이렇게 탐욕 선택 속성과 최적 부분 구조의 2가지 조건을 만족하면 최적해를 찾을 수 있다. 하지만 그렇지 않더라도 정답을 근사하게 찾는 용도로 활용되며, 대부분 계산 속도가 매우 빠르므로 실용적이다.


그리디 알고리즘은 최적 부분 구조 문제를 푼다는 점에서 다이나믹 프로그래밍과 비교되는데 서로 성격이 다르다.

다이나믹 프로그래밍은 하위 문제에 대한 최적의 솔루션을 찾은 다음, 이 결과들을 결합한 정보에 입각해 전역 최적 솔루션(Glovally Optimum Solution)에 대한 선택을 한다

그리디 알고리즘은 각 단계마다 로컬 최적해를 찾는 문제를 접근해 문제를 더 작게 줄여나가는 형태이다.

서로 반대되는 접근구조를 띤다.

ㅁ 배낭 문제

배낭 문제(Knapsack Problem)는 조합 최적화 분야의 매우 유명한 문제로, 배낭에 담을수 있는 최댓값이 정해져 있고, 짐의 가치와 무게가 있는 짐들을 배낭에 넣었 을 때 가치의 합이 최대가 되도록 고르는 방법문제.

짐을 쪼갤 수 있는 경우인 분할 가능 배낭 문제와 짐을 쪼갤수 없는 경우인 다이나믹 프로그래밍으로 나뉜다.

![image](https://user-images.githubusercontent.com/62640332/147485782-dc20c19c-4453-47b0-b52b-b04481a8696d.png)

분한 가능의 경우 단가가 가장 높은 짐부터 차례대로 채워 나가면된다.

C단가 2.5 가장 높으르모, D,B,E,D 순으로 총 8KG의 짐을 배낭에 담고 마지막 남은 7KG을 위해 A의 7/12만큼을 쪼개서 배당에 그리디 알고리즘으로 담는다.

이렇게 하면 17.3 최적해 찾을수 있다.

```
cargo = [
    (4, 12),
    (2, 1),
    (10, 4),
    (1, 1),
    (2, 2),
]

r = fractional_knapsack(cargo)
```
짐 cargo를 '(가격, 무게)'의 튜플 리스트로 정의후 함수를 호출한다.

단가 기준으로 알고리즘을 설명한 그대로 구현위해서, 단가를 계산하고 연순으로 정렬한다.

즉 가장 단가가 높은 짐이 맨위에 오도록 다음과 같이 구현한다.

```
for c in cargo:
    pack.append((c[0] / c[1], c[0], c[1]))
pack.sort(revser=True)
```
이제 단가 순으로 그리디 알고리즘 계산하면 된다.

![image](https://user-images.githubusercontent.com/62640332/147486258-519fa3e2-4123-4711-9648-8a2075fdd8e8.png)

ㅁ 동전 바꾸기 문제

동전의 액면이 10원, 50원, 100원 처럼 증가하면서 이전 액면의 배수 이상이 되면 그리디 알고리즘으로 풀수있따.

동전은 항상 배수 이상이므로 그리디로 풀 수 있다.

예를들어 160원을 거슬러 준다면, 10원 짜리 16개 보다는 100원x1, 50x1, 10원x1 짜리가로 각각 동전을 최대한 활용하는 그리디한 방법이 가장 적은 동전 개수로 거슬러 줄수 있는 방법이다.

그런데 만약 다른나라에 80원 짜리 동전이 있다고치면 그리디하게 풀 수 없다.
이경우 앞서 배낭 문제와 마찬가지로 다이나믹 프로그래밍으로 풀어야 한다.

ㅁ 가장 큰 합

그리디 알고리즘의 실패 사례로 노드를 계속 더해가다가 마지막에 가장 큰 합이 되는 경로를 찾는 문제 이다.

![image](https://user-images.githubusercontent.com/62640332/147576305-0f17f7ae-8f81-4297-8718-8d78483f21a2.png)


7부터 시작해 최종적으로 가장 큰 합을 만들기 위해선느 간선으로 연결된 2가지 선택지중 더 큰 수를 계속 더해나가면 될것 같지만, 매번 가장 큰 값을 취해 나가면
7, 12 ,6 을 선택하게 된다. 이러면 합이 25에 불가하지만, 7, 3, 9을 택하면 무려 109가 가능하다.

이문제는 이진 트리를 정렬한다든지 등의 추가 작업을 하지 않는 한 그리디 알고리즘으로 풀이할 수 없다.

ㅁ 주식을 사고팔기 가장 좋은 시점 590p

ㅁ 키에 따른 대기열 재구성 593p

ㅁ 태스크 스케줄러 595p

ㅁ 주유소 599p

ㅁ 쿠키 부여 603p



