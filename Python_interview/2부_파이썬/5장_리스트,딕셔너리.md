`궁금한점? 데크, 해시테이블`

ㅁ 리스트(List) : 순서대로 저장하는 시퀸스이자 변경 가능한 목록(Mutable List)

입력순서 유지, 내부적으로 동적 배열로 구현됨.

\# 언어별 동적 배열 구현

|언어|동적배열|
|---|---|
|파이썬|list()|
|C++| std::vector|
|자바|ArrayList|

파이썬은 다양한 기능을 제공하여 스택과 큐 등 무엇을 사용할지 고민할 필요 없음.   
==> 스택과 큐에서 사용가능한 모든 연산 가능

\# 리스트와 주요 연산 시간 복잡도

| 연산 | 시간 복잡도 | 설명 | 
|---|---|---|
|len(a)|O(1)|전체 요소의 개수 리턴|
|a[i]|O(1)| 인덱스 i의 요소 가져옴|
|a[i:j]|O(k)| i부터 j까지 슬라이스의 길이만큼 k개의 요소 가져온다. 이경우 객체 k개에 대한 조회가 필요하므로 O(k)|
|elem in a|O(n)| elem 요소가 존재하는지 확인, 처음부터 순차탐색이므로 n만큼 시간 소요|
|a.count(elem)| O(n)| elem요소의 개수 리턴|
|a.index(elem)| O(n)| elem요소의 인덱스 리턴|
|a.append(elem)| O(1)| 리스트 마지막에 elem 요소 추가|
|a.pop()| O(1) | 리스트 마지막 요소 추출. (스택연산임)|
|a.pop(0)| O(n) | 리스트 첫번째 요소 추출.(큐연산). 이경우 전체 보갓가 필요하므로 O(n). 큐 연산 주로 사용한다면 리스트보다는 O(1)에 가능한 데크(deque)권장|
|del a[i]| O(n) | i에 따라 다르다. 최악의 경우 O(n)|
|a.sort()| O(n log n) | 정렬한다. 팀소트(Timsort)를 사용하며, 최선의 경우 O(n)에도 싱행 될수 있다.|
|min(a),max(a)| O(n)|최솟값/최댓값 계산하기 위해서는 전체를 선형 탐색|
|a.reverse(n) |뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 된다.|

\# 데크 리스트보다 속도가 빠른 이유는??

리스트의 경우 탐색 시 값의 존재 유무를 확인하려면 정렬된 경우에는 이진 검색이 효율적.

그러나 매번 정렬이 필요하고, 대개는 리스트 정렬된 상태X

리스트의 경우에는 모든 엘맅먼트를 순차적으로 조회하는 형태로 구현되어있따. 이 경우 최악의 경우 항상 O(n) 소요.

- 다른 언어들은 동적 배열에 삽입할 수 있는 자룔형을 동일한 타이븡로 제한하는 경우 많음, 파이썬은 자유롭게 삽입 가능

- 존재하지 않는 인덱스 조회시 IndexError 발생

try 구문으로 예외처리 할수 있음.

```
try:
    print(a[9])
except IndexError:
    print('존재하지 않는 인덱스')
```

- 리스트에서 요소 삭제하는 방법.

1. 인덱스로 삭제   ---- del()
2. 값으로 삭제     ---- remove()

```
>>> a
[1, 2, 3, 5, 4, '안녕', True]

>>> del a[1]
>>> a
[1, 3, 5, 4, '안녕, True]

>>> a.pop(3)
'안녕'

>>> a
[1, 5, 4, True]
```

- CPython에서 리스트는 요소에 대한 포인터 목록을 갖고 있는 구조체(Struct)로 선언되어 있다.

리스트에 요소 추가 및 제거시 ob_item의 사이즈를 조절해 나가는 형태로 구현

==> 리스트는 객체로 되어있는 모든 자료형을 다음과 같이 포인터로 연결

![image](https://user-images.githubusercontent.com/62640332/144735716-bb726198-ee9f-4498-b634-e1a8880766cb.png)


파이썬의 모든것은 객채, 파이썬의 리스트는 객체에 대한 포인터 목록을 관리하는 형태로 구현.

사실상 연결 리스트에 대한 포인터 목록을 배열 형태로 관리, 그 덕분에 파이썬의 리스트는 배열과 연결 리스트를 합친 듯이 강력한 기능 자랑

- 파이썬의 리스트는 다양한 자료형을 할당   

==> 각 자료형의 크기는 저마다 서로 다르기 때문에 연속된 메모리 공간게 할당 불가능.

==> 각각의 객체에 대한 참조로 구현할 수밖에 없다.

\# 인덱스를 조회하는 데에도 모든 포인터의 위치를 찾아가서 타입 코드를 확인하고, 값을 일일이 살펴봐야 하는 등 추가작업 필요해서 속도 느린 특징 가짐.

---
<br>

딕셔너리 : 파이썬 3.7+에서는 입력 순서가 유지 및 내부적으로는 해시 테이블(Hash Table)로 구현, 

3.6 이하에서는 입력순서 유지되지않아서 collections.OrderDict() 별도 자료형 제공

+) 3.6 이후 딕셔너리 메모리 사용량 20% 감소

- 각 언어별 해시 테이블 구현

|언어|해시 테이블|
|---|---|
|파이썬|dict()|
|C++|std::unordered_map|
|자바|HashMap|

- 리스트는 인덱스를 수자로만 지정할수 있다.   
- 딕셔너리는 문자를 포함해 다양한 타입을 키로 사용할수 있다.

파이썬의 딕셔너리는 해시할 수만 있다면 숫자뿐만 아니라, 문자, 집합까지 불변 객체를 모두 키로 사용할 수 있다.    
=> 이과정을 해싱 이라고함.

해시 테이블을 이용해 자료를 저장

-장점
1. 해시 테이블은 다양한 타입을 키로 지원하면서 입력과 조회 모두 O(1) 가능 물론 최악의 경우 O(n) 이 되룻가 있음.
   
|연산|시간복잡도|설명|
|---|---|---|
|len(a)| O(1)| 요소의 개수 리턴|
|a[key]| O(1)| 키를 조회하여 값을 리턴|
|a[key] = value| 키/값을 삽입한다.|
|key in a| O(1)| 딕셔너리에 키가 존재하는지 확인

\# 해시 테이블 시간 복잡도가 낮은 이유???

이처럼 딕셔너리는 키/값 구조의 데이터 저장하는 유용한 자료형

- 딕셔너리 활용 방법

 ```
>>> a = {'key':'value1', 'key2':'value2'}
>>> a
{'key':'value1', 'key2':'value2'}

>>> a['key3'] = 'value3'
{'key':'value1', 'key2':'value2', 'key3':'value3'}
```

딕셔너리에서 존재하지 않는 키 조회시 KeyError 발생   
try 구문으로 예외처리 가능
```
try:
    print(a['key4'])
except KeyError:
    print('존재하지않는 키')
```

딕셔너리에 있는 키/값은 items() 메소드 이용하여 각각 꺼내기 가능
```
>>> for k,v in a.items():
    print(k,v)
...
...
key1 value1
key2 value2
key3 value3
```

```
>>> def a['key1']
>>> a
{'key': 'value2', 'key3': 'value3'}
```

ㅁ 딕셔너리 모듈

1. defaultdict 객체 : 존재하지 않는 키 조회할경우 에러 메세지를 출력하는 대신 디폴트 값을 기준으로 해당 키에대한 딕셔너리 아이템 생성. 실제로 collections.defaultdict 클래스 가진다.

```
>>> a = collections.defaultdict(int)
>>> a['A'] = 5
>>> a['B'] = 4
>>> a
defaultcit(<class 'int'>, {'A': 5, 'B': 4})

>>> ㅁ['C'] += 1
>>> a
defaultdict(<class 'int'>, {'A': 5, 'B': 4, 'C':1})
```

2. Counter객체 : 아이템에 대한 개수를 계산해 딕셔너리로 리턴

```
>>> a = [1, 2, 3, 4, 5, 5, 5, 6, 6]
>>> b = collections.Counter(a)
>>> b
Counter({5: 3, 6:2, 1:1, 2:1, 3:1, 4:1})
```

Counter객체는 이처럼 키에는 아이템의 값이, 값에는 해당 아이템의 개수가 들어간 딕셔너리를 생성.

실제로는 딕셔너리를 한 번 더 래핑(Wrapping)한 collections.Counter 클래스를 갖는다.


```
type(b)
<class 'collections.Counter'>
```

가장 빈도수가 높은 요소 추출법 most_common()

```
>>> b.most_common(2)
[(5,3), (6,2)]
```
이처럼 가장높은 2개의요소 추출

3. OrderDcit 객체 : 입력값을 부여할 경우 OrderDict는 입력 그대로 순서를 유지된다.

```
>>> collections.DorderDict({'banana': 3, 'apple':4, 'pear':1, 'orange': 2})
OrderDict([({'banana': 3, 'apple':4, 'pear':1, 'orange': 2})])
```

파이썬 3.7부터 딕셔너리는 내부적으로 인덱스를 이용하여 순서가 유지되도록 개선됨.

- 타입 선언
```
>>> type([])
<class 'list'>

>>> type(())
<class 'tuple'>

>>> type({})
<class 'dict'>

>>> type ({1})
<class 'set'>
```
